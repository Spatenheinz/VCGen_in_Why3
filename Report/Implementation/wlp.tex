\paragraph{Implementation of Weakest Liberal Precondition calculus.}
We implemented the rules for weakest liberal precondition by a recursive function that directly
follows the inference rules.
We focus on two of the rules, namely assignments and while statements, which both does substitution in the formula.
For assignments we define the rule as follows:

\begin{lstlisting}
| Sass x e -> let y = fresh_from q in
              Fall y (Fimp (Fand (Fterm (Bleq (Avar y) e))
                                 (Fterm (Bleq e (Avar y)))) (subst_fmla q x y))
\end{lstlisting}

We first generate a fresh variable, which is then substituted into the postcondition $Q$.
We further follow the semantics, however since we do not have equality we use $y \leq e \wedge e \leq y$.

The other interesting rule, for while, is implemented as follows:
\begin{lstlisting}
| Swhile cond inv body ->
  Fand inv
       (abstract_effects body
       (Fand (Fimp (Fand (Fterm cond) inv) (wp body inv))
             (Fimp (Fand (Fnot (Fterm cond)) inv) q))
       )
\end{lstlisting}

Here the interesting thing is the function \texttt{abstract\_effects}. This function quantifies over all assigned variables in the body of the loop and substitute the quantifiers with the free variables in the formula
$((cond \wedge inv) \Rightarrow wp(body,inv)) \wedge ((\neg cond \wedge inv) \Rightarrow Q)$. like \texttt{fresh\_from} this function is inspired by \cite{TODO}. The story is the same. They used axioms to define the function, whereas we have to implement it.
\texttt{abstract\_effects} takes a statement $s$ and formula $f$.
If the statement is an assignment
a fresh variable is made and substituted into $f$, and we then quantify the freshly made variable.
This is not the most efficient solution, as multiple assignment to the same variable will create unused quantifiers.
All the cases will traverse the abstract syntaxt tree or is a leaf and does nothing.

\begin{lstlisting}
let rec function abstract_effects (s : stmt int) (f : formula int) : formula int
  variant { s }
= match s with
  | Sskip | Sassert _ -> f
  | Sseq s1 s2 | Sif _ s1 s2 -> abstract_effects s2 (abstract_effects s1 f)
  | Sass x _ -> let v = fresh_from f in
                let f' = subst_fmla f x v in
                Fall v f'
  | Swhile _ _ s -> abstract_effects s f
  end
\end{lstlisting}

Whilst we implemented this function directly, we still want the properties for the function to hold.
\parapgraph{specialization.} Firstly, we have

\begin{lstlisting}
  lemma abstract_effects_specialize : forall st : store int, s f.
    eval_formula (abstract_effects s f) st -> eval_formula f st
\end{lstlisting}

which states that evaluation of applying abstract effects off s on f in state st implies that f evaluates to true in st. Essentially it states that if we quantify the variables in f and the formula is true under the quantification, then $f$ also hold if the variables are not quantified.
THIS DOES NOT MAKE ANY SENSE??? PLEASE LOOK AT IT TOMORROW.

\paragraph{Quatification over conjunction.}
Secondly, we have
\begin{lstlisting}
lemma abstract_effects_distrib_conj : forall s p q st.
   eval_formula (abstract_effects s p) st /\ eval_formula (abstract_effects s q) st ->
   eval_formula (abstract_effects s (Fand p q)) st
 \end{lstlisting}

Which states that if we apply abstract effects of s on two formulas p and q and they both evaluates to true,
then evaluating the result of applying the abstract effects of s over the conjunction of p and q, must also be true.

\paragraph{Monotonicity.}
Thirdly, we have the property of monotonicity.

\begin{lstlisting}
lemma abstract_effects_monotonic : forall s p q.
   valid_formula (Fimp p q) ->
   forall st. eval_formula (abstract_effects s p) st ->
   eval_formula (abstract_effects s q) st
 \end{lstlisting}

Essentially what monotonicity states, is that applying additional assumptions to a formula will not change the meaning. It should be noted that we want to quantify all states in the entailment, as the property does not hold for a fixed state.

\paragraph{Invariance.}
Lastly, we consider the notion of invariance.
TODO: I DONT THINK THIS IS NECESSARY.

In \cite{TODO} the axiomatized version of the following lemma, is used to define which variables should be quantified.
We explicitly state this in the body of \texttt{abstract\_effects},
but for good measure we include it as a lemma. The property states that if a the formula $q$ abstracted by $s$ is true in some state, then the weakest precondition on the same abstraction on $q$ by $s$ is true should also be true. When \cite{} uses this as an axiom, it ensures, that \texttt{abstract\_effects}

\paragraph{Proofs of properties for abstract\_effects}
We have not been able to automatically prove these lemmas in why3.
At the moment we have a partial proof for the function in Isabelle.
???? WRITE SOME MORE ????

\paragraph{Properties and Soundness of WLP}
One of the main goals in making a formally verified Verification condition generator is to ensure the correctness of the implementation.
We consider the correctness through its soundness.
To do so we must consider two of the same properties we just stated for a\texttt{abstract\_effects}, namely monotonicity and conjunction distribution.

Monotonicity of WLP is that if for two formulas $p$ and $q$ the formula $\vDash p \Rightarrow q$ then $\vDash wp(s, p) \Rightarrow wp(s,q)$. Notice again that this must hold for all statements and states.
Distribution of weakest precondition over conjuction, is similar to the lemma of abstract effects only the transformation on $p$ and $q$ are now considered for $wp$.

\begin{lstlistings}
lemma monotonicity: forall s p q.
      valid_formula (Fimp p q) -> valid_formula (Fimp (wp s p) (wp s q))

lemma distrib_conj: forall s sigma p q.
      eval_formula (wp s p) sigma /\ eval_formula (wp s q) sigma ->
      eval_formula (wp s (Fand p q)) sigma
\end{lstlistings}

Once again we, we not able to directly show this. We tried to unfold the recursion on $s$, in a similar manner to how we proved determinism.
We did not achieve anything by this.
We have a formalized proof of both properties in Isabelle.
The proof for monotonicity can be seen in \cite{lst:isamono}.
As mentioned we prove the lemma by induction on $s$.
And mark $p$ and $q$ as arbitrary, since the lemma should hold for any non-fixed $p$ and $q$.
The proof only shows the cases for sequences, assignments and while.
The case for sequences are actually directly proved from the assumptions.
We only distinguish this case because we need to simplify the other trivial cases.
For both assignment and while we used the sledgehammer to find the proofs by metis,
which is a complete automatic theorem prover for first order logic with equality\cite{TODO sledgehammer paper}.

\begin{lstlisting}[caption={Proof of monotonicity in Isabelle},label={lst:isamono},language=sml]
lemma monotonicity : "valid_formula (FImp p q) \<Longrightarrow>
  valid_formula (FImp (wp s p) (wp s q))"
proof(induction s arbitrary: p q)
  case (SSeq s1 s2)
  then show ?case by auto
next
  case (Sassign x1 x2)
  then show ?case
    by (metis abstract_effect_writes abstract_effects.simps(2)
         eval_formula.simps(2) valid_formula_def wp.simps(3))
next
  case (Swhile x1 x2 s)
  then show ?case
    by (metis abstract_effect_writes abstract_effects.simps(2)
        eval_formula.simps(2) valid_formula_def wp.simps(3))
qed (simp_all add: valid_formula_def)
\end{lstlisting}

For distribution over a conjuction, the proof is straight forward.
We do induction with the same setup.
Again the sequences, assignments and while cannot trivially be proved by simplification,
but the same metis proof used for monotonicity can be used for all three cases.

With these two properties, we should be able to show soundness for the wp function.
We decided to not prove the completeness of the function because this says something about the expressiveness of the function, whereas it is more important to ensure that
the function is correct.
Using soundness to show correctness is two-fold.
On the one hand showing the soundness of $wp$ ensures that $\hoare{wp(s,Q)}{s}{Q}$ is valid for partial correctness for all $s$ and $q$, ensures that we cannot generate invalid verification conditions.
On the other hand, we already know weakest precondition to be sound and proving it for the function $wp$ ensures that our implementation adheres to the semantics or atleast an equivalent semantic.

We have not gotten to show this.
TODO why have we not done this?????