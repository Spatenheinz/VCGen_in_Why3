module WP

  use grammar.Grammar
  use grammar.Formula
  use semantics.Semantics
  use subst.Subst
  use list.List
  use list.Mem
  use int.Int

  let rec function mem (x: int) (l: list int) = match l with
    | Nil      -> false
    | Cons y r -> x = y || mem x r
    end

  let rec function assigned_vars (s : stmt int) (vars: list int) : list int
      variant { s }
  = match s with
    | Sskip -> vars
    | Sseq s1 s2 -> assigned_vars s2 (assigned_vars s1 vars)
    | Sass x _ -> Cons x vars
    | Sassert _ -> vars
    | Sif _ s1 s2 -> assigned_vars s2 (assigned_vars s1 vars)
    | Swhile _ _ s -> assigned_vars s vars
    end

  let rec function abstract_all_vars (vars : list int) (seen : list int) (f : formula int) : formula int
      variant { vars }
  = match vars with
    | Nil -> f
    | Cons x xs -> if mem x seen then
                     abstract_all_vars xs seen f
                   else
                     let v = fresh_from f in
                     let f' = subst_fmla f x v in
                     abstract_all_vars xs (Cons x seen) (Fall v f')
    end

  (* let function abstract_effects (s : stmt int) (f : formula int) : formula int *)
  (* = let vars = assigned_vars s Nil in *)
  (*   abstract_all_vars vars Nil f *)

  let rec function abstract_effects (s : stmt int) (f : formula int) : formula int
    variant { s }
    (* ensures { forall st. eval_formula result st -> eval_formula f st  } *)
  = match s with
    | Sskip | Sassert _ -> f
    | Sseq s1 s2 | Sif _ s1 s2 -> abstract_effects s2 (abstract_effects s1 f)
    | Sass x _ -> let v = fresh_from f in
                  let f' = subst_fmla f x v in
                  Fall v f'
    | Swhile _ _ s -> abstract_effects s f
    end

  lemma abstract_effects_specialize : forall st : store int, s f.
    eval_formula (abstract_effects s f) st -> eval_formula f st

  (* let rec lemma abstract_effects_specialize (s : stmt int) (f : formula int) (st: store int) *)
  (*    requires {  eval_formula (abstract_effects s f) st  } *)
  (*    ensures { eval_formula f st } *)
  (* = match s with *)
  (*   | Sskip | Sass _ _ | Sassert _ -> () *)
  (*   | Sseq s1 s2 | Sif _ s1 s2 -> abstract_effects_specialize s1 f st; abstract_effects_specialize s2 f st *)
  (*   | Swhile _ _ s -> abstract_effects_specialize s f st *)
  (*   end *)


  lemma abstract_effects_distrib_conj : forall s p q st.
     eval_formula (abstract_effects s p) st /\ eval_formula (abstract_effects s q) st ->
     eval_formula (abstract_effects s (Fand p q)) st

  (* let rec lemma abstract_effects_specialize (s : stmt int) (p q: formula int) (st: store int) *)
  (*    requires { eval_formula (abstract_effects s p) st /\ eval_formula (abstract_effects s q) st  } *)
  (*    ensures { eval_formula (abstract_effects s (Fand p q)) st } *)
  (* = match s with *)
  (*   | Sskip | Sass _ _ | Sassert _ -> () *)
  (*   | Sseq s1 s2 | Sif _ s1 s2 -> abstract_effects_specialize s1 p q st; abstract_effects_specialize s2 p q st *)
  (*   | Swhile _ _ s -> abstract_effects_specialize s p q st *)
  (*   end *)

  lemma abstract_effects_monotonic : forall s p q.
     valid_formula (Fimp p q) -> forall st. eval_formula (abstract_effects s p) st -> eval_formula (abstract_effects s q) st


  (* {WP(s,Q)} s {Q} *)
  let rec function wp (s: stmt int) (q: formula int) : formula int
    variant { s }
  = match s with
    (* WP(skip, Q) = Q *)
    | Sskip -> q
    (* WP(s1;s2, Q) = WP(s1, WP(s2, Q)) *)
    | Sseq s1 s2 -> wp s1 (wp s2 q)
    (* WP(assert P, Q) = P /\ Q   *)
    (* TODO this vs traditional way *)
    | Sassert p -> Fand p (Fimp p q)
    (* | Sassert p -> Fand p q *)
    (* WP(x := e, Q) = ∀ y . y = e → Q[x ← y] *)
    | Sass x e -> let y = fresh_from q in
                  Fall y (Fimp (Fand (Fterm (Bleq (Avar y) e))
                                     (Fterm (Bleq e (Avar y)))) (subst_fmla q x y))
    (* WP(if b {s1} else {s2}, Q) = (b -> WP(s1, Q)) /\ (not b -> WP(s2, Q))*)
    | Sif b s1 s2 -> Fand (Fimp (Fterm b) (wp s1 q))
                          (Fimp (Fnot (Fterm b)) (wp s2 q))
    (* inv /\ ∀xi (((cond /\ inv) -> WP(body, inv)) *)
    (*             /\ ((¬cond /\ inv) -> Q))[wi ← xi]  *)
    | Swhile cond inv body ->
      Fand inv
           (abstract_effects body
           (Fand (Fimp (Fand (Fterm cond) inv) (wp body inv))
                 (Fimp (Fand (Fnot (Fterm cond)) inv) q))
           )
    end

  lemma abstract_effect_writes : forall st s q.
     eval_formula (abstract_effects s q) st -> eval_formula (wp s (abstract_effects s q)) st

  lemma monotonicity: forall s p q.
        valid_formula (Fimp p q) -> valid_formula (Fimp (wp s p) (wp s q))

  lemma distrib_conj: forall s sigma p q.
        eval_formula (wp s p) sigma /\ eval_formula (wp s q) sigma ->
        eval_formula (wp s (Fand p q)) sigma

end
