module Semantics

  use int.Int
  use map.Map
  use set.Fset
  use grammar.Grammar
  use grammar.Formula
  use option.Option

  type e_behaviour = Eint int | Eunbound | Ebool bool

  (* predicate eval_aexpr2 (a: aexpr) (st: state) = *)
  (*   match a with *)
  (*   | Acst _ -> true *)
  (*   | Avar x -> st[x] <> None *)
  (*   | Asub a1 a2 -> eval_aexpr2 a1 st /\ eval_aexpr2 a2 st *)
  (*   end *)

  inductive eval_aexpr aexpr state e_behaviour =
    | eval_cst : forall n s.
               eval_aexpr (Acst n) s (Eint n)
    | eval_var : forall x n s.
               s[x] = Some n ->
               eval_aexpr (Avar x) s (Eint n)
    | eval_var_err : forall x s.
               s[x] = None ->
               eval_aexpr (Avar x) s Eunbound
    | eval_sub : forall a1 a2 n1 n2 s.
               eval_aexpr a1 s (Eint n1) ->
               eval_aexpr a2 s (Eint n2) ->
               eval_aexpr (Asub a1 a2) s (Eint (n1 - n2))
    | eval_sub_err1 : forall a1 a2 s.
               eval_aexpr a1 s Eunbound ->
               eval_aexpr (Asub a1 a2) s Eunbound
    | eval_sub_err2 : forall a1 a2 s.           (* can we skip eval of a1? *)
               (* eval_aexpr a1 s (Eint n1) -> *)
               eval_aexpr a2 s Eunbound ->
               eval_aexpr (Asub a1 a2) s Eunbound

  let rec ghost function id_in_aexpr (a: aexpr) =
      match a with
      | Acst _ -> empty
      | Avar v -> singleton v
      | Asub a1 a2 -> union (id_in_aexpr a1) (id_in_aexpr a2)
      end

 (** Ken: We can describe evaluation of expressions as a total function *)
  let rec lemma eval_aexpr_total_fun (a: aexpr) (s: state)
       variant { a }
       ensures { eval_aexpr a s result }
     = match a with
       | Acst n -> Eint n
       | Avar v -> match s[v] with
                     | Some n -> Eint n
                     | None -> Eunbound
                   end
       | Asub a1 a2 ->
         match eval_aexpr_total_fun a1 s, eval_aexpr_total_fun a2 s with
           | Eint n1, Eint n2 -> Eint (n1 - n2)
           | _ -> Eunbound
         end
       end

  (* It does not work when we dont define the induction ourselfs *)
  (* lemma eval_aexpr_fun : forall a s b1 b2. *)
  (*    eval_aexpr a s b1 -> eval_aexpr a s b2 -> b1 = b2 *)

  let rec lemma eval_aexpr_fun (a: aexpr) (s: state)
      variant { a }
      ensures { forall b1 b2. eval_aexpr a s b1 ->
                              eval_aexpr a s b2 ->
                              b1 = b2
      }
    = match a with
      | Acst _ | Avar _ -> ()
      | Asub a1 a2 ->
        eval_aexpr_fun a1 s; eval_aexpr_fun a2 s
      end

  let rec lemma eval_aexpr_total (a: aexpr)
      ensures { forall s:state.
          eval_aexpr a s Eunbound \/ exists n. eval_aexpr a s (Eint n)
      }
    = match a with
      | Acst _ | Avar _ -> ()
      | Asub a1 a2 -> eval_aexpr_total a1; eval_aexpr_total a2
      end

  inductive eval_bexpr bexpr state e_behaviour =
    | eval_true : forall s.
                eval_bexpr Btrue s (Ebool true)
    | eval_false : forall s.
                eval_bexpr Bfalse s (Ebool false)
    | eval_leq_true  : forall a1 a2 n1 n2 s.
                eval_aexpr a1 s (Eint n1) ->
                eval_aexpr a2 s (Eint n2) ->
                (* n1 <= n2 -> *)
                eval_bexpr (Bleq a1 a2) s (Ebool (n1 <= n2))
    (* | eval_leq_false  : forall a1 a2 n1 n2 s. *)
    (*             eval_aexpr a1 s (Eint n1) -> *)
    (*             eval_aexpr a2 s (Eint n2) -> *)
    (*             n1 > n2 -> *)
    (*             eval_bexpr (Bleq a1 a2) s (Ebool false) *)
    | eval_leq_err1 : forall a1 a2 s.
                eval_aexpr a1 s Eunbound ->
                eval_bexpr (Bleq a1 a2) s Eunbound
    | eval_leq_err2 : forall a1 a2 n1 s.
                eval_aexpr a1 s (Eint n1) ->
                eval_aexpr a2 s Eunbound ->
                eval_bexpr (Bleq a1 a2) s Eunbound
    (* | eval_band_true : forall b1 b2 b1' b2' s. *)
    (*             eval_bexpr b1 s (Ebool b1') -> *)
    (*             eval_bexpr b2 s (Ebool b2') -> *)
    (*             b1' && b2' -> *)
    (*             eval_bexpr (Band b1 b2) s (Ebool true) *)
    (* | eval_band_false : forall b1 b2 b1' b2' s. *)
    (*             eval_bexpr b1 s (Ebool b1') -> *)
    (*             eval_bexpr b2 s (Ebool b2') -> *)
    (*             not (b1' && b2') -> *)
    (*             eval_bexpr (Band b1 b2) s (Ebool false) *)
    (* | eval_band_err1 : forall b1 b2 s. *)
    (*             eval_bexpr b1 s Eunbound -> *)
    (*             eval_bexpr (Band b1 b2) s Eunbound *)
    (* | eval_band_err2 : forall b1 b1' b2 s. *)
    (*             eval_bexpr b1 s (Ebool b1') -> *)
    (*             eval_bexpr b2 s Eunbound -> *)
    (*             eval_bexpr (Band b1 b2) s Eunbound *)
    | eval_bnot : forall b b' s.
                eval_bexpr b s (Ebool b') ->
                eval_bexpr (Bnot b) s (Ebool (not b'))
    | eval_bnot_err : forall b s.
                eval_bexpr b s Eunbound ->
                eval_bexpr (Bnot b) s Eunbound

  let rec lemma eval_bexpr_total_fun (b: bexpr) (s: state)
       variant { b }
       ensures { eval_bexpr b s result }
     = match b with
       | Btrue -> Ebool true
       | Bfalse -> Ebool false
       | Bleq a1 a2 -> match eval_aexpr_total_fun a1 s, eval_aexpr_total_fun a2 s with
                       | (Eint n1, Eint n2) -> Ebool (n1 <= n2)
                       | _ -> Eunbound
                       end
       (* | Band b1 b2 -> match eval_bexpr_total_fun b1 s, eval_bexpr_total_fun b2 s with *)
       (*                 (\* | (Ebool True, Ebool True) -> Ebool true *\) *)
       (*                 (\* | (Ebool True, Ebool False) -> Ebool false *\) *)
       (*                 (\* | (Ebool False, Ebool True) -> Ebool false *\) *)
       (*                 (\* | (Ebool False, Ebool False) -> Ebool false *\) *)
       (*                 | (Ebool b1', Ebool b2') -> Ebool (b1' && b2') *)
       (*                 | _ -> Eunbound *)
       (*                 end *)
       | Bnot b     -> match eval_bexpr_total_fun b s with
                       | Ebool b' -> Ebool (not b')
                       | _ -> Eunbound
                       end
       end

  type s_behaviour = Snormal | Sunbound

  inductive eval_stmt state stmt state s_behaviour =
    | eval_skip : forall st.
          eval_stmt st Sskip st Snormal
    | eval_ass  : forall st x e n.
          eval_aexpr e st (Eint n) ->
          let st' = st[x <- Some n] in
          eval_stmt st (Sass x e) st' Snormal
    | eval_ass_error  : forall st x e.
          eval_aexpr e st Eunbound ->
          eval_stmt st (Sass x e) st Sunbound
    | eval_seq  : forall s1 s2 st st' st'' bhv.
          eval_stmt st s1 st' Snormal ->
          eval_stmt st' s2 st'' bhv ->
          eval_stmt st (Sseq s1 s2) st'' bhv
    | eval_seq_error  : forall s1 s2 st st' bhv.
          eval_stmt st s1 st' bhv ->
          bhv <> Snormal ->
          eval_stmt st (Sseq s1 s2) st' bhv

  let rec lemma seval_deterministic (s: stmt) (st: state)
       variant { s }
       ensures { forall st'' bhv. eval_stmt st s result bhv ->
                                      eval_stmt st s st'' bhv ->
                                      result = st''
       }
     = match s with
       | Sskip -> st
       | Sass x a -> match eval_aexpr_total_fun a st with
                     | Eint i -> st[x <- Some i]
                     | Ebool _ -> st
                     | Eunbound -> st
                     end
       | Sseq s1 s2 ->
         let st1 = seval_deterministic s1 st in seval_deterministic s2 st1
       end


  lemma seval_determ_aux : forall s st st' bhv.
     eval_stmt st s st' bhv -> forall st''. (eval_stmt st s st'' bhv) -> st' = st''


  lemma seval_determ : forall s st st' st'' bhv.
     eval_stmt st s st' bhv -> eval_stmt st s st'' bhv -> st' = st''

  (* inductive eval_formula state formula = *)
  (*   | Fterm b -> eval_bexpr st *)

end


  (*   goal G1: forall s:state. eval_bexpr Btrue s (Ebool true) *)

  (*   goal G2: forall n1 n2:int, s:state. eval_bexpr (Bleq (Acst n1) (Acst n2)) s (Ebool (n1 <= n2)) *)
