module Semantics

  use int.Int
  use map.Map
  use set.Fset
  use grammar.Grammar
  use grammar.Formula
  use option.Option

  type error = Eunbound (*| Ediv0 *)

  type e_behaviour 'a = Enormal 'a | Eabnormal error

  let function eval_op (op : aop) : (int -> int -> int) =
      match op with
      | Mul -> (*) | Sub -> (-) | Add -> (+)
      end

  inductive eval_aexpr (aexpr 'a) (store 'a) (e_behaviour int) =
    | EACst : forall n, s : store 'a.
               eval_aexpr (Acst n) s (Enormal n)
    | EAVar : forall x n, s : store 'a.
               s[x] = Some n ->
               eval_aexpr (Avar x) s (Enormal n)
    | EAVar_err : forall x, s : store 'a.
               s[x] = None ->
               eval_aexpr (Avar x) s (Eabnormal Eunbound)
    | EABin : forall a1 a2 n1 n2, s : store 'a, op.
               eval_aexpr a1 s (Enormal n1) ->
               eval_aexpr a2 s (Enormal n2) ->
               eval_aexpr (ABin a1 op a2) s (Enormal ((eval_op op) n1 n2))
    (* | EASub : forall a1 a2 n1 n2, s : store 'a, op. *)
    (*            eval_aexpr a1 s (Enormal n1) -> *)
    (*            eval_aexpr a2 s (Enormal n2) -> *)
    (*            op = Sub -> *)
    (*            eval_aexpr (ABin a1 op a2) s (Enormal (n1 - n2)) *)
    (* | EAMul : forall a1 a2 n1 n2, s : store 'a, op. *)
    (*            eval_aexpr a1 s (Enormal n1) -> *)
    (*            eval_aexpr a2 s (Enormal n2) -> *)
    (*            op = Mul -> *)
    (*            eval_aexpr (ABin a1 op a2) s (Enormal (n1 * n2)) *)
    (* | EAAdd : forall a1 a2 n1 n2, s : store 'a, op. *)
    (*            eval_aexpr a1 s (Enormal n1) -> *)
    (*            eval_aexpr a2 s (Enormal n2) -> *)
    (*            op = Add -> *)
    (*            eval_aexpr (ABin a1 op a2) s (Enormal (n1 + n2)) *)
    | EAOp_err1 : forall a1 a2, s : store 'a, op e.
               eval_aexpr a1 s (Eabnormal e) ->
               eval_aexpr (ABin a1 op a2) s (Eabnormal e)
    | EAOp_err2 : forall a1 a2 n1, s : store 'a, op e.           (* can we skip eval of a1? *)
               eval_aexpr a1 s (Enormal n1) ->
               eval_aexpr a2 s (Eabnormal e) ->
               eval_aexpr (ABin a1 op a2) s (Eabnormal e)


  lemma eval_aexpr_total_cannot_show : forall a, s : store 'a.
    eval_aexpr a s (Eabnormal Eunbound) \/ exists n. eval_aexpr a s (Enormal n)
 (** Ken: We can describe evaluation of expressions as a total function *)
  let rec lemma eval_aexpr_total_fun (a: aexpr 'a) (s: store 'a)
       variant { a }
       ensures { eval_aexpr a s result }
     = match a with
       | Acst n -> Enormal n
       | Avar v -> match s[v] with
                     | Some n -> Enormal n
                     | None -> Eabnormal Eunbound
                   end
       | ABin a1 op a2 ->
         match eval_aexpr_total_fun a1 s, eval_aexpr_total_fun a2 s with
           | Enormal n1, Enormal n2 -> Enormal ((eval_op op) n1 n2)
           | Eabnormal e, _   -> Eabnormal e
           | _ , Eabnormal e  -> Eabnormal e
         end
       end


  (* It does not work when we dont define the induction ourselfs *)
  lemma eval_aexpr_fun_cannot_show : forall a, s : store 'a, b1 b2.
     eval_aexpr a s b1 -> eval_aexpr a s b2 -> b1 = b2

  let rec lemma eval_aexpr_fun (a: aexpr 'a) (s: store 'a)
      variant { a }
      ensures { forall b1 b2. eval_aexpr a s b1 ->
                              eval_aexpr a s b2 ->
                              b1 = b2
      }
    = match a with
      | Acst _ | Avar _ -> ()
      | ABin a1 _ a2 ->
        eval_aexpr_fun a1 s; eval_aexpr_fun a2 s
      end

  let rec lemma eval_aexpr_total (a: aexpr 'a)
      ensures { forall s:store 'a.
          eval_aexpr a s (Eabnormal Eunbound) \/ exists n. eval_aexpr a s (Enormal n)
      }
    = match a with
      | Acst _ | Avar _ -> ()
      | ABin a1 _ a2 -> eval_aexpr_total a1; eval_aexpr_total a2
      end

  inductive eval_bexpr (bexpr 'a) (store 'a) (e_behaviour bool) =
    | EBCst      : forall b, s : store 'a.
                   eval_bexpr (BCst b) s (Enormal b)
    | EBLeq      : forall a1 a2 n1 n2, s : store 'a.
                   eval_aexpr a1 s (Enormal n1) ->
                   eval_aexpr a2 s (Enormal n2) ->
                   (* n1 <= n2 -> *)
                   eval_bexpr (Bleq a1 a2) s (Enormal (n1 <= n2))
    | EBLeq_err1 : forall a1 a2, s : store 'a.
                   eval_aexpr a1 s (Eabnormal Eunbound) ->
                   eval_bexpr (Bleq a1 a2) s (Eabnormal Eunbound)
    | EBLeq_err2 : forall a1 a2 n1, s : store 'a.
                   eval_aexpr a1 s (Enormal n1) ->
                   eval_aexpr a2 s (Eabnormal Eunbound) ->
                   eval_bexpr (Bleq a1 a2) s (Eabnormal Eunbound)
    | EBAnd      : forall b1 b2 b1' b2', s: store 'a.
                   eval_bexpr b1 s (Enormal b1') ->
                   eval_bexpr b2 s (Enormal b2') ->
                   (* b1' && b2' -> *)
                   eval_bexpr (Band b1 b2) s (Enormal (b1' && b2'))
    | EBAnd_err1 : forall b1 b2, s : store 'a.
                   eval_bexpr b1 s (Eabnormal Eunbound) ->
                   eval_bexpr (Band b1 b2) s (Eabnormal Eunbound)
    | EBAnd_err2 : forall b1 b1' b2, s : store 'a.
                   eval_bexpr b1 s (Enormal b1') ->
                   eval_bexpr b2 s (Eabnormal Eunbound) ->
                   eval_bexpr (Band b1 b2) s (Eabnormal Eunbound)
    | EBNot      : forall b b', s : store 'a.
                   eval_bexpr b s (Enormal b') ->
                   eval_bexpr (Bnot b) s (Enormal (not b'))
    | EBNot_err  : forall b, s : store 'a.
                   eval_bexpr b s (Eabnormal Eunbound) ->
                   eval_bexpr (Bnot b) s (Eabnormal Eunbound)

  let rec lemma eval_bexpr_total_fun (b: (bexpr 'a)) (s: (store 'a))
       variant { b }
       ensures { eval_bexpr b s result }
     = match b with
       | BCst b     -> Enormal b
       | Bleq a1 a2 -> match eval_aexpr_total_fun a1 s, eval_aexpr_total_fun a2 s with
                       | Enormal n1, Enormal n2 -> Enormal (n1 <= n2)
                       | Eabnormal e, _   -> Eabnormal e
                       | _ , Eabnormal e  -> Eabnormal e
                       end
       | Band b1 b2 -> match eval_bexpr_total_fun b1 s, eval_bexpr_total_fun b2 s with
                       | Enormal b1', Enormal b2' -> Enormal (b1' && b2')
                       | Eabnormal e, _   -> Eabnormal e
                       | _ , Eabnormal e  -> Eabnormal e
                       end
       | Bnot b     -> match eval_bexpr_total_fun b s with
                       | Enormal b' -> Enormal (not b')
                       | e   -> e
                       end
       end

  lemma eval_bexpr_fun_cannot_show : forall b, s : store 'a, b1 b2.
     eval_bexpr b s b1 -> eval_bexpr b s b2 -> b1 = b2

  lemma eval_bexpr_total_cannot_show : forall b, s : store 'a.
    eval_bexpr b s (Eabnormal Eunbound) \/ exists n. eval_bexpr b s (Enormal n)

  let rec lemma eval_bexpr_fun (b : bexpr 'a) (s : store 'a)
      variant { b }
      ensures { eval_bexpr b s (Eabnormal Eunbound) \/ exists n. eval_bexpr b s (Enormal n) }
  = match b with
    | BCst _ -> ()
    | Bleq a1 a2 -> eval_aexpr_fun a1 s; eval_aexpr_fun a2 s
    | Band b1 b2 -> eval_bexpr_fun b1 s; eval_bexpr_fun b2 s
    | Bnot b     -> eval_bexpr_fun b s
    end
  let rec lemma eval_bexpr_total (b : bexpr 'a) (s : store 'a)
      variant { b }
      ensures { forall b1 b2. eval_bexpr b s b1 ->
                              eval_bexpr b s b2 ->
                              b1 = b2
      }
  = match b with
    | BCst _ -> ()
    | Bleq a1 a2 -> eval_aexpr_fun a1 s; eval_aexpr_fun a2 s
    | Band b1 b2 -> eval_bexpr_fun b1 s; eval_bexpr_fun b2 s
    | Bnot b     -> eval_bexpr_fun b s
    end

  inductive eval_stmt (stmt 'a) (store 'a) (e_behaviour (store 'a)) =
    | eval_skip : forall st : store 'a.
          eval_stmt Sskip st (Enormal st)
    | eval_ass  : forall st : store 'a, x : 'a, e n.
          eval_aexpr e st (Enormal n) ->
          let st' = st[x <- Some n] in
          eval_stmt (Sass x e) st (Enormal st')
    | eval_ass_error  : forall st : store 'a, x e.
          eval_aexpr e st (Eabnormal Eunbound) ->
          eval_stmt (Sass x e) st (Eabnormal Eunbound)
    | eval_seq  : forall s1 s2, st  st'' : store 'a, bhv : e_behaviour (store 'a).
          eval_stmt s1 st (Enormal st'') ->
          eval_stmt s2 st'' bhv ->
          eval_stmt (Sseq s1 s2) st bhv
    | eval_seq_error  : forall s1 s2, st st' : store 'a, bhv : e_behaviour 'a.
          eval_stmt st s1 st' bhv ->
          bhv <> (Enormal ()) ->
          eval_stmt st (Sseq s1 s2) st' bhv

(*   (\* let rec lemma seval_deterministic (s: stmt) (st: (store 'a)) *\) *)
(*   (\*      variant { s } *\) *)
(*   (\*      ensures { forall st'' bhv. eval_stmt st s result bhv -> *\) *)
(*   (\*                                     eval_stmt st s st'' bhv -> *\) *)
(*   (\*                                     result = st'' *\) *)
(*   (\*      } *\) *)
(*   (\*    = match s with *\) *)
(*   (\*      | Sskip -> st *\) *)
(*   (\*      | Sass x a -> match eval_aexpr_total_fun a st with *\) *)
(*   (\*                    | (Enormal ()) i -> st[x <- Some i] *\) *)
(*   (\*                    | (Enormal ()) _ -> st *\) *)
(*   (\*                    | (Eabnormal Eunbound) -> st *\) *)
(*   (\*                    end *\) *)
(*   (\*      | Sseq s1 s2 -> *\) *)
(*   (\*        let st1 = seval_deterministic s1 st in seval_deterministic s2 st1 *\) *)
(*   (\*      end *\) *)


(*   (\* lemma seval_determ_aux : forall s st st' bhv. *\) *)
(*   (\*    eval_stmt st s st' bhv -> forall st''. (eval_stmt st s st'' bhv) -> st' = st'' *\) *)


(*   (\* lemma seval_determ : forall s st st' st'' bhv. *\) *)
(*   (\*    eval_stmt st s st' bhv -> eval_stmt st s st'' bhv -> st' = st'' *\) *)

(*   predicate eval_formula (f: formula 'a) (st: (store 'a))  = *)
(*     match f with *)
(*     | Fterm b -> eval_bexpr b st (Enormal true) *)
(*     | Fand f1 f2 -> eval_formula f1 st /\ eval_formula f2 st *)
(*     | Fnot f -> not (eval_formula f st) *)
(*     | Fimp f1 f2 -> eval_formula f1 st -> eval_formula f2 st *)
(*     | Fall y f -> forall n. eval_formula f st[y <- n] *)
(*     end *)

(*   (\* goal G1 : forall st. eval_formula (Fand (Fterm (Btrue)) (Fterm (Btrue))) st *\) *)
(*   (\* goal A  : forall n1 n2 st. n1 <= n2 -> *\) *)
(*   (\*                   eval_formula (Fterm (Bleq (Acst n1) (Acst n2))) st *\) *)
(*   (\* goal Imp : forall st. eval_formula (Fimp (Fterm Btrue) (Fterm Btrue)) st *\) *)
(*   (\* goal AbsurdImp : forall st. eval_formula (Fimp (Fterm Bfalse) *\) *)
(*   (\*                                                (Fterm (Bleq (Acst 4) (Acst 1)))) st *\) *)
(*   (\* goal ImpNone : forall st y x. eval_formula (Fimp (Fterm (Bleq (Avar y) (Acst x))) *\) *)
(*   (\*                                             (Fterm (Bleq (Avar y) (Acst (x+1)))) *\) *)
(*   (\*                                       ) st *\) *)
(*   (\* goal Simp : forall st y. eval_formula (Fall y (Fterm (Btrue))) st *\) *)
(*   (\* goal ALL : forall st y. eval_formula (Fall y (Fimp (Fterm (Bleq (Avar y) (Acst 5))) *\) *)
(*   (\*                                                   (Fterm (Bleq (Avar y) (Acst 6))) *\) *)
(*   (\*                                 ) *\) *)
(*   (\*                         ) st *\) *)
(*   (\* goal A2  : forall st. eval_formula (Fterm (Bleq (Acst 4) (Acst 3))) st *\) *)
(*   (\* goal G2 : forall st. eval_formula (Fand (Fterm (Btrue)) (Fterm (Bfalse))) st *\) *)
(*   (\* goal False' : forall st. eval_formula (Fterm (Bfalse)) st *\) *)

(*   goal test : forall y x. y <= x -> y <= x + 1 *)

(*   predicate valid_formula (f : formula 'a) = forall sigma: (store 'a). eval_formula f sigma *)

(*   (\* goal G1 : valid_formula (Fand (Fterm (Btrue)) (Fterm (Btrue))) *\) *)
(*   (\* goal G1 : valid_formula (Fand (Fterm (Btrue)) (Fimp (Fterm Btrue) (Fterm (Btrue))) : formula int) *\) *)
(*   (\* goal A  : forall n1 n2. n1 <= n2 -> *\) *)
(*   (\*                   valid_formula (Fterm (Bleq (Acst n1) (Acst n2))) *\) *)
(*   (\* goal Imp : valid_formula (Fimp (Fterm Btrue) (Fterm Btrue)) *\) *)
(*   (\* goal AbsurdImp : valid_formula (Fimp (Fterm Bfalse) *\) *)
(*   (\*                                                (Fterm (Bleq (Acst 4) (Acst 1)))) *\) *)
(*   (\* goal ImpNone : forall n1 x. valid_formula (Fimp (Fterm (Bleq (Acst n1) (Acst x))) *\) *)
(*   (\*                                             (Fterm (Bleq (Acst n1) (Acst (x+1)))) *\) *)
(*   (\*                                       ) *\) *)
(*   (\* goal Simp : forall y. valid_formula (Fall y (Fterm (Btrue))) *\) *)
(*   (\* goal ALL : forall y. valid_formula (Fall y (Fimp (Fterm (Bleq (Avar y) (Acst 5))) *\) *)
(*   (\*                                                   (Fterm (Bleq (Avar y) (Acst 6))) *\) *)
(*   (\*                                 ) *\) *)
(*   (\*                         ) *\) *)
(*   (\* goal A2  : valid_formula (Fterm (Bleq (Acst 4) (Acst 3))) *\) *)
(*   (\* goal G2 : valid_formula (Fand (Fterm (Btrue)) (Fterm (Bfalse))) *\) *)
(*   (\* goal False' : valid_formula (Fterm (Bfalse)) *\) *)

end


(*   (\*   goal G1: forall s:state. eval_bexpr Btrue s ((Enormal ()) true) *\) *)

(*   (\*   goal G2: forall n1 n2:int, s:state. eval_bexpr (Bleq (Acst n1) (Acst n2)) s ((Enormal ()) (n1 <= n2)) *\) *)
