(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require map.Map.
Require option.Option.

Axiom set : forall (a:Type), Type.
Parameter set_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (set a).
Existing Instance set_WhyType.

Parameter mem: forall {a:Type} {a_WT:WhyType a}, a -> (set a) -> Prop.

Parameter infix_eqeq:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (set a) -> Prop.

Axiom infix_eqeq_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a),
  (infix_eqeq s1 s2) <-> forall (x:a), (mem x s1) <-> (mem x s2).

Axiom extensionality :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), (infix_eqeq s1 s2) -> (s1 = s2).

Parameter subset:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (set a) -> Prop.

Axiom subset_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a),
  (subset s1 s2) <-> forall (x:a), (mem x s1) -> mem x s2.

Axiom subset_refl :
  forall {a:Type} {a_WT:WhyType a}, forall (s:set a), subset s s.

Axiom subset_trans :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a) (s3:set a), (subset s1 s2) ->
  (subset s2 s3) -> subset s1 s3.

Parameter is_empty: forall {a:Type} {a_WT:WhyType a}, (set a) -> Prop.

Axiom is_empty_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), (is_empty s) <-> forall (x:a), ~ (mem x s).

Parameter empty: forall {a:Type} {a_WT:WhyType a}, set a.

Axiom empty_def : forall {a:Type} {a_WT:WhyType a}, is_empty (empty : set a).

Parameter add: forall {a:Type} {a_WT:WhyType a}, a -> (set a) -> set a.

Axiom add_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set a), forall (y:a),
  (mem y (add x s)) <-> ((y = x) \/ (mem y s)).

Parameter remove: forall {a:Type} {a_WT:WhyType a}, a -> (set a) -> set a.

Axiom remove_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set a), forall (y:a),
  (mem y (remove x s)) <-> (~ (y = x) /\ (mem y s)).

Axiom add_remove :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set a), (mem x s) -> ((add x (remove x s)) = s).

Axiom remove_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set a), ((remove x (add x s)) = (remove x s)).

Axiom subset_remove :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set a), subset (remove x s) s.

Parameter union:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (set a) -> set a.

Axiom union_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), forall (x:a),
  (mem x (union s1 s2)) <-> ((mem x s1) \/ (mem x s2)).

Parameter inter:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (set a) -> set a.

Axiom inter_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), forall (x:a),
  (mem x (inter s1 s2)) <-> ((mem x s1) /\ (mem x s2)).

Parameter diff:
  forall {a:Type} {a_WT:WhyType a}, (set a) -> (set a) -> set a.

Axiom diff_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), forall (x:a),
  (mem x (diff s1 s2)) <-> ((mem x s1) /\ ~ (mem x s2)).

Axiom subset_diff :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), subset (diff s1 s2) s1.

Parameter choose: forall {a:Type} {a_WT:WhyType a}, (set a) -> a.

Axiom choose_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), ~ (is_empty s) -> mem (choose s) s.

Parameter cardinal: forall {a:Type} {a_WT:WhyType a}, (set a) -> Z.

Axiom cardinal_nonneg :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), (0%Z <= (cardinal s))%Z.

Axiom cardinal_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), ((cardinal s) = 0%Z) <-> (is_empty s).

Axiom cardinal_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a), forall (s:set a), ~ (mem x s) ->
  ((cardinal (add x s)) = (1%Z + (cardinal s))%Z).

Axiom cardinal_remove :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a), forall (s:set a), (mem x s) ->
  ((cardinal s) = (1%Z + (cardinal (remove x s)))%Z).

Axiom cardinal_subset :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), (subset s1 s2) ->
  ((cardinal s1) <= (cardinal s2))%Z.

Axiom subset_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set a) (s2:set a), (subset s1 s2) ->
  ((cardinal s1) = (cardinal s2)) -> infix_eqeq s1 s2.

Axiom cardinal1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set a), ((cardinal s) = 1%Z) -> forall (x:a), (mem x s) ->
  (x = (choose s)).

Axiom program_var : Type.
Parameter program_var_WhyType : WhyType program_var.
Existing Instance program_var_WhyType.

(* Why3 assumption *)
Inductive expr :=
  | Elit : Z -> expr
  | Evar : program_var -> expr
  | Esub : expr -> expr -> expr.
Axiom expr_WhyType : WhyType expr.
Existing Instance expr_WhyType.

(* Why3 assumption *)
Inductive cmd :=
  | Cskip : cmd
  | Cassign : program_var -> expr -> cmd
  | Cseq : cmd -> cmd -> cmd
  | Cif : expr -> cmd -> cmd -> cmd
  | Cwhile : expr -> cmd -> cmd.
Axiom cmd_WhyType : WhyType cmd.
Existing Instance cmd_WhyType.

(* Why3 assumption *)
Definition environment := program_var -> (option Z).

(* Why3 assumption *)
Inductive expr_behaviour :=
  | Enormal : Z -> expr_behaviour
  | Eunbound_var : expr_behaviour.
Axiom expr_behaviour_WhyType : WhyType expr_behaviour.
Existing Instance expr_behaviour_WhyType.

(* Why3 assumption *)
Inductive eval_expr: (program_var -> (option Z)) -> expr -> expr_behaviour ->
  Prop :=
  | eval_lit :
      forall (env:program_var -> (option Z)) (n:Z),
      eval_expr env (Elit n) (Enormal n)
  | eval_var :
      forall (env:program_var -> (option Z)) (x:program_var) (n:Z),
      ((env x) = (Init.Datatypes.Some n)) ->
      eval_expr env (Evar x) (Enormal n)
  | eval_var_undefined :
      forall (env:program_var -> (option Z)) (x:program_var),
      ((env x) = Init.Datatypes.None) -> eval_expr env (Evar x) Eunbound_var
  | eval_sub :
      forall (env:program_var -> (option Z)) (e1:expr) (e2:expr) (n1:Z)
        (n2:Z),
      (eval_expr env e1 (Enormal n1)) -> (eval_expr env e2 (Enormal n2)) ->
      eval_expr env (Esub e1 e2) (Enormal (n1 - n2)%Z)
  | eval_sub_error1 :
      forall (env:program_var -> (option Z)) (e1:expr) (e2:expr),
      (eval_expr env e1 Eunbound_var) ->
      eval_expr env (Esub e1 e2) Eunbound_var
  | eval_sub_error2 :
      forall (env:program_var -> (option Z)) (e1:expr) (e2:expr) (n1:Z),
      (eval_expr env e1 (Enormal n1)) -> (eval_expr env e2 Eunbound_var) ->
      eval_expr env (Esub e1 e2) Eunbound_var.

(* Why3 assumption *)
Fixpoint identifiers_in_expr (e:expr) {struct e}: set program_var :=
  match e with
  | Elit _ => empty : set program_var
  | Evar v => add v (empty : set program_var)
  | Esub e1 e2 => union (identifiers_in_expr e1) (identifiers_in_expr e2)
  end.

Axiom eval_expr_functional :
  forall (env:program_var -> (option Z)) (e:expr),
  forall (n1:expr_behaviour) (n2:expr_behaviour), (eval_expr env e n1) ->
  (eval_expr env e n2) -> (n1 = n2).

Axiom eval_expr_total :
  forall (e:expr), forall (gamma:program_var -> (option Z)),
  (eval_expr gamma e Eunbound_var) \/
  exists n:Z, eval_expr gamma e (Enormal n).

(* Why3 assumption *)
Inductive behavior :=
  | Cnormal : behavior
  | Cunbound_var : behavior
  | Cloop_limit : behavior.
Axiom behavior_WhyType : WhyType behavior.
Existing Instance behavior_WhyType.

Axiom config : Type.
Parameter config_WhyType : WhyType config.
Existing Instance config_WhyType.

Parameter loop_limit: config -> (option Z).

Axiom config'invariant :
  forall (self:config),
  match loop_limit self with
  | Init.Datatypes.None => True
  | (Init.Datatypes.Some n) => (0%Z <= n)%Z
  end.

Parameter mk_loop_cnf: Z -> config.

Axiom mk_loop_cnf_def :
  forall (n:Z), (0%Z <= n)%Z ->
  ((loop_limit (mk_loop_cnf n)) = (Init.Datatypes.Some n)).

Parameter no_loop_limit_cnf: config.

Axiom no_loop_limit_cnf1 :
  ((loop_limit no_loop_limit_cnf) = Init.Datatypes.None).

(* Why3 assumption *)
Inductive exec_cmd: config -> (program_var -> (option Z)) -> cmd ->
  (program_var -> (option Z)) -> behavior -> Prop :=
  | exec_skip :
      forall (env:program_var -> (option Z)) (cnf:config),
      exec_cmd cnf env Cskip env Cnormal
  | exec_assign :
      forall (cnf:config) (env:program_var -> (option Z)) (v:program_var)
        (e:expr) (n:Z),
      (eval_expr env e (Enormal n)) ->
      exec_cmd cnf env (Cassign v e)
      (map.Map.set env v (Init.Datatypes.Some n)) Cnormal
  | exec_assign_error :
      forall (cnf:config) (env:program_var -> (option Z)) (v:program_var)
        (e:expr),
      (eval_expr env e Eunbound_var) ->
      exec_cmd cnf env (Cassign v e) env Cunbound_var
  | exec_seq :
      forall (cnf:config) (env1:program_var -> (option Z)) (c1:cmd) (c2:cmd)
        (env2:program_var -> (option Z)) (env3:program_var -> (option Z))
        (bhv:behavior),
      (exec_cmd cnf env1 c1 env2 Cnormal) ->
      (exec_cmd cnf env2 c2 env3 bhv) ->
      exec_cmd cnf env1 (Cseq c1 c2) env3 bhv
  | exec_seq_error :
      forall (cnf:config) (env1:program_var -> (option Z)) (c1:cmd) (c2:cmd)
        (env2:program_var -> (option Z)) (bhv:behavior),
      (exec_cmd cnf env1 c1 env2 bhv) -> ~ (bhv = Cnormal) ->
      exec_cmd cnf env1 (Cseq c1 c2) env2 bhv
  | exec_if_false :
      forall (cnf:config) (env:program_var -> (option Z)) (e:expr) (c1:cmd)
        (c2:cmd) (env':program_var -> (option Z)) (bhv:behavior),
      (eval_expr env e (Enormal 0%Z)) -> (exec_cmd cnf env c2 env' bhv) ->
      exec_cmd cnf env (Cif e c1 c2) env' bhv
  | exec_if_true :
      forall (cnf:config) (env:program_var -> (option Z)) (e:expr) (c1:cmd)
        (c2:cmd) (n:Z) (env':program_var -> (option Z)) (bhv:behavior),
      ~ (n = 0%Z) -> (eval_expr env e (Enormal n)) ->
      (exec_cmd cnf env c1 env' bhv) ->
      exec_cmd cnf env (Cif e c1 c2) env' bhv
  | exec_if_error :
      forall (cnf:config) (env:program_var -> (option Z)) (e:expr) (c1:cmd)
        (c2:cmd),
      (eval_expr env e Eunbound_var) ->
      exec_cmd cnf env (Cif e c1 c2) env Cunbound_var
  | exec_while :
      forall (cnf:config) (env:program_var -> (option Z)) (e:expr) (c:cmd)
        (env':program_var -> (option Z)) (bhv:behavior),
      (exec_while1 cnf 0%Z env e c env' bhv) ->
      exec_cmd cnf env (Cwhile e c) env' bhv
  with exec_while1: config -> Z -> (program_var -> (option Z)) -> expr ->
  cmd -> (program_var -> (option Z)) -> behavior -> Prop :=
  | exec_while_overflow :
      forall (cnf:config) (ctr:Z) (env:program_var -> (option Z)) (e:expr)
        (c:cmd),
      match loop_limit cnf with
      | Init.Datatypes.None => False
      | (Init.Datatypes.Some n) => (n <= ctr)%Z
      end -> exec_while1 cnf ctr env e c env Cloop_limit
  | exec_while_false :
      forall (cnf:config) (env:program_var -> (option Z)) (ctr:Z) (e:expr)
        (c:cmd),
      match loop_limit cnf with
      | Init.Datatypes.None => True
      | (Init.Datatypes.Some n) => (ctr < n)%Z
      end -> (eval_expr env e (Enormal 0%Z)) ->
      exec_while1 cnf ctr env e c env Cnormal
  | exec_while_test_error :
      forall (cnf:config) (env:program_var -> (option Z)) (ctr:Z) (e:expr)
        (c:cmd),
      match loop_limit cnf with
      | Init.Datatypes.None => True
      | (Init.Datatypes.Some n) => (ctr < n)%Z
      end -> (eval_expr env e Eunbound_var) ->
      exec_while1 cnf ctr env e c env Cunbound_var
  | exec_while_body_error :
      forall (cnf:config) (env1:program_var -> (option Z)) (ctr:Z) (e:expr)
        (c:cmd) (v:Z) (env2:program_var -> (option Z)) (bhv:behavior),
      match loop_limit cnf with
      | Init.Datatypes.None => True
      | (Init.Datatypes.Some n) => (ctr < n)%Z
      end -> (eval_expr env1 e (Enormal v)) -> ~ (v = 0%Z) ->
      (exec_cmd cnf env1 c env2 bhv) -> ~ (bhv = Cnormal) ->
      exec_while1 cnf ctr env1 e c env2 bhv
  | exec_while_loop :
      forall (cnf:config) (env1:program_var -> (option Z)) (ctr:Z) (e:expr)
        (c:cmd) (v:Z) (env2:program_var -> (option Z))
        (env3:program_var -> (option Z)) (bhv:behavior),
      match loop_limit cnf with
      | Init.Datatypes.None => True
      | (Init.Datatypes.Some n) => (ctr < n)%Z
      end -> (eval_expr env1 e (Enormal v)) -> ~ (v = 0%Z) ->
      (exec_cmd cnf env1 c env2 Cnormal) ->
      (exec_while1 cnf (ctr + 1%Z)%Z env2 e c env3 bhv) ->
      exec_while1 cnf ctr env1 e c env3 bhv.

Scheme exec_cmd_rec := Induction for exec_cmd Sort Prop
  with exec_while_rec := Induction for exec_while1 Sort Prop.

Combined Scheme exec_cmd_while_rec from exec_cmd_rec,exec_while_rec.

(* Why3 goal *)
Theorem no_loop_limits :
  (forall (cnf:config) (env1:program_var -> (option Z)) (c:cmd)
     (env2:program_var -> (option Z)) (bhv:behavior),
   (exec_cmd cnf env1 c env2 bhv) ->
   ((loop_limit cnf) = Init.Datatypes.None) -> ~ (bhv = Cloop_limit)) /\
  forall (cnf:config) (ctr:Z) (env1:program_var -> (option Z)) (e:expr)
    (c:cmd) (env2:program_var -> (option Z)) (bhv:behavior),
  (exec_while1 cnf ctr env1 e c env2 bhv) ->
  ((loop_limit cnf) = Init.Datatypes.None) -> ~ (bhv = Cloop_limit).
Proof.
  apply
    (exec_cmd_while_rec
       (fun cnf env1 c env2 bhv exec => loop_limit cnf = None -> ~(bhv=Cloop_limit))
       (fun cnf ctr env1 e c env2 bhv exec => loop_limit cnf = None -> ~(bhv=Cloop_limit)));
    (discriminate || auto).
  intros. rewrite H in y. inversion y.
Qed.

