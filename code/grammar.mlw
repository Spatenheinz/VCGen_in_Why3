module Grammar

  use option.Option

  type id = int
  type state = id -> option int

  type aexpr =
       | Acst int
       | Avar id
       | Asub aexpr aexpr

  type bexpr =
       | Btrue
       | Bfalse
       | Bleq aexpr aexpr
       (* | Band bexpr bexpr *)
       | Bnot bexpr

  type stmt =
       | Sskip
       | Sass id aexpr
       | Sseq stmt stmt

  type prog = stmt

end

module Formula

  use Grammar
  use int.Int
  use int.MinMax

  type value = Vint int | Vbool bool

  (* type term = *)
  (*   | Tvalue value *)
  (*   | Tvar id *)
  (*   | Tghost id *)
    (* | Tbin *)

  type formula =
    | Fterm bexpr
    | Fand formula formula
    | Fnot formula
    | Fimp formula formula
    (* Flet = Fall *)
    (* let x = t in f ≍ ∀ y. y = t → f[x ← y] *)
    | Fall id formula

  (* predicate fresh_in_aexpr (id: id) (a: aexpr) = *)
  (*   match a with *)
  (*   | Acst _ -> true *)
  (*   | Avar v   -> id <> v *)
  (*   | Asub a1 a2 -> fresh_in_aexpr id a1 /\ fresh_in_aexpr id a2 *)
  (*   end *)

  (* predicate fresh_in_bexpr (id: id) (b: bexpr) = *)
  (*   match b with *)
  (*   | Bleq a1 a2 -> fresh_in_aexpr id a1 /\ fresh_in_aexpr id a2 *)
  (*   | _ -> true *)
  (*   end *)

  (* predicate fresh_in_formula (id: id) (f: formula) = *)
  (*   match f with *)
  (*   | Fterm b -> fresh_in_bexpr id b *)
  (*   | Fand f1 f2 | Fimp f1 f2 -> fresh_in_formula id f1 /\ fresh_in_formula id f2 *)
  (*   | Fnot f -> fresh_in_formula id f *)
  (*   | Fall y f -> id <> y /\ fresh_in_formula id f *)
  (*   end *)

  (* function fresh_from (f: formula) : id *)

  (* axiom fresh_from_formula: forall f: formula. *)
  (*   fresh_in_formula (fresh_from f) f *)


  (* let rec function fresh_in_aexpr (id : id) (a: aexpr) : bool *)
  (*   variant { a } *)
  (* = match a with *)
  (*   | Acst _ -> true *)
  (*   | Avar v   -> id <> v *)
  (*   | Asub a1 a2 -> fresh_in_aexpr id a1 && fresh_in_aexpr id a2 *)
  (*   end *)

  (* let rec function fresh_in_bexpr (id: id) (b: bexpr) : bool *)
  (*   variant { b } *)
  (* = match b with *)
  (*   | Bleq a1 a2 -> fresh_in_aexpr id a1 && fresh_in_aexpr id a2 *)
  (*   | _ -> true *)
  (*   end *)

  (* let rec function fresh_in_formula (id: id) (f: formula) : bool *)
  (*   variant { f } *)
  (* = match f with *)
  (*   | Fterm b -> fresh_in_bexpr id b *)
  (*   | Fand f1 f2 | Fimp f1 f2 -> fresh_in_formula id f1 && fresh_in_formula id f2 *)
  (*   | Fnot f -> fresh_in_formula id f *)
  (*   | Fall y f -> id <> y && fresh_in_formula id f *)
  (*   end *)

  (* let rec fresh_from_aux (f: formula) (id : id) : id *)
  (*     diverges *)
  (* = *)
  (*     if fresh_in_formula id f then id *)
  (*     else fresh_from_aux f (id + 1) *)

  (* let fresh_from (f: formula) : id *)
  (*     diverges *)
  (* =   fresh_from_aux f 0 *)
  let rec function max_id_aexpr (id : id) (a: aexpr) : id
    variant { a }
  = match a with
    | Acst _ -> id
    | Avar v   -> max id v
    | Asub a1 a2 -> max (max_id_aexpr id a1) (max_id_aexpr id a2)
    end

  let rec function max_id_bexpr (id: id) (b: bexpr) : id
    variant { b }
  = match b with
    | Bleq a1 a2 -> max (max_id_aexpr id a1) (max_id_aexpr id a2)
    | _ -> id
    end

  let rec function max_id_formula (id: id) (f: formula) : id
    variant { f }
  = match f with
    | Fterm b -> max_id_bexpr id b
    | Fand f1 f2 | Fimp f1 f2 -> max (max_id_formula id f1) (max_id_formula id f2)
    | Fnot f -> max_id_formula id f
    | Fall y f -> max y (max_id_formula id f)
    end

  let fresh_from (f: formula) : id = max_id_formula 0 f + 1

(* pred occurs_in id term -> bool *)
(* lemma fresh af term => does not occur *)




end
