module Grammar

  use option.Option

  type id = int
  type store 'a = 'a -> option int

  type aop = Mul | Sub | Add

  type aexpr 'a =
       | Acst int
       | Avar 'a
       | ABin (aexpr 'a) aop (aexpr 'a)

  type bexpr 'a =
       | BCst bool
       | Bleq (aexpr 'a) (aexpr 'a)
       | Band (bexpr 'a) (bexpr 'a)
       | Bnot (bexpr 'a)

  type formula 'a =
    | Fterm (bexpr 'a)
    | Fand (formula 'a) (formula 'a)
    | Fnot (formula 'a)
    | Fimp (formula 'a) (formula 'a)
    (* Flet = Fall *)
    (* let x = t in f ≍ ∀ y. y = t → f[x ← y] *)
    | Fall 'a (formula 'a)

  type stmt 'a =
       | Sskip
       | Sass 'a (aexpr 'a)
       | Sseq (stmt 'a) (stmt 'a)
       | Sassert (formula 'a)
       | Sif (bexpr 'a) (stmt 'a) (stmt 'a)
       | Swhile (bexpr 'a) (formula 'a) (stmt 'a)

  type prog 'a = stmt 'a

end

module Formula

  use Grammar
  use int.Int
  use int.MinMax
  use bool.Bool
  use set.Set

  predicate fresh_in_aexpr (id: 'a) (a: aexpr 'a)
  = match a with
    | Acst _ -> true
    | Avar v   -> id <> v
    | ABin a1 _ a2 -> andb (fresh_in_aexpr id a1) (fresh_in_aexpr id a2)
    end

  predicate fresh_in_bexpr (id: 'a) (b: bexpr 'a) =
    match b with
    | Bleq a1 a2 -> fresh_in_aexpr id a1 /\ fresh_in_aexpr id a2
    | Band b1 b2 -> fresh_in_bexpr id b1 /\ fresh_in_bexpr id b2
    | Bnot b -> fresh_in_bexpr id b
    | BCst _ -> true
    end

  predicate fresh_in_formula (id: 'a) (f: formula 'a) =
    match f with
    | Fterm b                 -> fresh_in_bexpr id b
    | Fand f1 f2 | Fimp f1 f2 -> fresh_in_formula id f1 /\ fresh_in_formula id f2
    | Fnot f                  -> fresh_in_formula id f
    | Fall y f                -> id <> y /\ fresh_in_formula id f
    end

  let rec function max_id_aexpr (id : id) (a: aexpr id) : id
    variant { a }
    ensures { result >= id }
  = match a with
    | Acst _       -> id
    | Avar v       -> max id v
    | ABin a1 _ a2 -> max (max_id_aexpr id a1) (max_id_aexpr id a2)
    end

  let rec function max_id_bexpr (id: id) (b: bexpr id) : id
    variant { b }
  = match b with
    | Bleq a1 a2 -> max (max_id_aexpr id a1) (max_id_aexpr id a2)
    | Band b1 b2 -> max (max_id_bexpr id b1) (max_id_bexpr id b2)
    | Bnot b     -> max_id_bexpr id b
    | BCst _     -> id
    end

  let rec function max_id_formula (id: id) (f: formula id) : id
    variant { f }
  = match f with
    | Fterm b                 -> max_id_bexpr id b
    | Fand f1 f2 | Fimp f1 f2 -> max (max_id_formula id f1) (max_id_formula id f2)
    | Fnot f                  -> max_id_formula id f
    | Fall y f                -> max y (max_id_formula id f)
    end

  let function fresh_from (f: formula id) : id
  = max_id_formula 0 f + 1

  function vars_in_aexpr (a : aexpr 'a) : set 'a
  = match a with
    | (Acst _) -> empty
    | (Avar v) -> singleton v
    | (ABin a1 _ a2) -> union (vars_in_aexpr a1) (vars_in_aexpr a2)
    end

  lemma max_id_trivial : forall a. max_id_aexpr 0 a >= 0

  let rec lemma max_id_geq (a : aexpr int)
    variant { a }
    ensures { forall x. mem x (vars_in_aexpr a) -> result >= x }
  = match a with
    | (Acst n) -> max_id_aexpr 0 (Acst n)
    | (Avar v) -> max_id_aexpr 0 (Avar v)
    | (ABin a1 op a2) -> max_id_aexpr 0 (ABin a1 op a2)
    end

  (* lemma max_id_geq : forall v a. *)
  (*    v = max_id_aexpr 0 a -> *)

  (* lemma fresh_var_max_plus_1 : forall f v. *)
  (*     v = fresh_from f -> v = max_id_formula 0 f + 1 *)

  (* lemma fresh_var_trivial : forall v : id. *)
  (*     fresh_in_formula v (Fterm (Bleq (Acst 5) (Acst 6))) *)

  (* lemma fresh_var_trivial2 : forall v f. *)
  (*     f = (Fterm (Bleq (Acst 5) (Acst 6))) -> *)
  (*     v = fresh_from f -> fresh_in_formula v f *)

  (* lemma fresh_var_trivial3 : forall v f. *)
  (*     f = (Fterm (Bleq (Acst 5) (Acst 6))) -> *)
  (*     v = fresh_from f -> v = 1 *)

  (* lemma max_is_not_fresh : forall v a. *)
  (*     (v = max_id_aexpr 0 a) -> not (fresh_in_aexpr v a) *)

  (* lemma breaks_stuff : forall a : aexpr 'a. *)
  (*   a <> a *)
  (* lemma fresh_var_in_aexpr : forall a v. *)
  (*     v = max_id_aexpr 0 a -> fresh_in_aexpr (v + 1) a *)

  (* lemma fresh_var_is_fresh : forall f [@induction] v. *)
  (*     v = fresh_from f -> fresh_in_formula v f *)

(* pred occurs_in id term -> bool *)
(* lemma fresh af term => does not occur *)

  (* function fresh_from (f: (formula 'a)) : id *)

  (* axiom fresh_from_formula: forall f: (formula 'a). *)
  (*   fresh_in_formula (fresh_from f) f *)


  (* let rec function fresh_in_aexpr (id : 'a) (a: aexpr 'a) : bool *)
  (*   variant { a } *)
  (* = match a with *)
  (*   | Acst _ -> true *)
  (*   | Avar v   -> id <> v *)
  (*   | ABin a1 _ a2 -> fresh_in_aexpr id a1 && fresh_in_aexpr id a2 *)
  (*   end *)

  (* let rec function fresh_in_bexpr (id: 'a) (b: bexpr 'a) : bool *)
  (*   variant { b } *)
  (* = match b with *)
  (*   | Bleq a1 a2 -> fresh_in_aexpr id a1 && fresh_in_aexpr id a2 *)
  (*   | Band b1 b2 -> fresh_in_bexpr id b1 && fresh_in_bexpr id b2 *)
  (*   | Bnot b -> fresh_in_bexpr id b *)
  (*   | BCst _ -> true *)
  (*   end *)

  (* let rec function fresh_in_formula (id: 'a) (f: formula 'a) : bool *)
  (*   variant { f } *)
  (* = match f with *)
  (*   | Fterm b -> fresh_in_bexpr id b *)
  (*   | Fand f1 f2 | Fimp f1 f2 -> fresh_in_formula id f1 && fresh_in_formula id f2 *)
  (*   | Fnot f -> fresh_in_formula id f *)
  (*   | Fall y f -> id <> y && fresh_in_formula id f *)
  (*   end *)

  (* let rec function fresh_from_aux (f: formula 'a) (id : 'a) : 'a *)
  (*     diverges *)
  (* = *)
  (*     if fresh_in_formula id f then id *)
  (*     else fresh_from_aux f (id + 1) *)

  (* let fresh_from (f: (formula 'a)) : id *)
  (*     diverges *)
  (* =   fresh_from_aux f 0 *)







end
