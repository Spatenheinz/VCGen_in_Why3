module Grammar

  use option.Option

  type id = int
  type state = id -> option int

  type aexpr =
       | Acst int
       | Avar id
       | Asub aexpr aexpr

  type bexpr =
       | Btrue
       | Bfalse
       | Bleq aexpr aexpr
       (* | Band bexpr bexpr *)
       | Bnot bexpr

  type stmt =
       | Sskip
       | Sass id aexpr
       | Sseq stmt stmt

  type prog = stmt

end

module Formula

  use Grammar
  use int.Int

  type value = Vint int | Vbool bool

  (* type term = *)
  (*   | Tvalue value *)
  (*   | Tvar id *)
  (*   | Tghost id *)
    (* | Tbin *)

  type formula =
    | Fterm bexpr
    | Fand formula formula
    | Fnot formula
    | Fimp formula formula
    (* Flet = Fall *)
    (* let x = t in f ≍ ∀ y. y = t → f[x ← y] *)
    | Fall id formula

  (* predicate fresh_in_aexpr (id: id) (a: aexpr) = *)
  (*   match a with *)
  (*   | Acst _ -> true *)
  (*   | Avar v   -> id <> v *)
  (*   | Asub a1 a2 -> fresh_in_aexpr id a1 /\ fresh_in_aexpr id a2 *)
  (*   end *)

  (* predicate fresh_in_bexpr (id: id) (b: bexpr) = *)
  (*   match b with *)
  (*   | Bleq a1 a2 -> fresh_in_aexpr id a1 /\ fresh_in_aexpr id a2 *)
  (*   | _ -> true *)
  (*   end *)

  (* predicate fresh_in_formula (id: id) (f: formula) = *)
  (*   match f with *)
  (*   | Fterm b -> fresh_in_bexpr id b *)
  (*   | Fand f1 f2 | Fimp f1 f2 -> fresh_in_formula id f1 /\ fresh_in_formula id f2 *)
  (*   | Fnot f -> fresh_in_formula id f *)
  (*   | Fall y f -> id <> y /\ fresh_in_formula id f *)
  (*   end *)

  (* function fresh_from (f: formula) : id *)

  (* axiom fresh_from_formula: forall f: formula. *)
  (*   fresh_in_formula (fresh_from f) f *)


  let rec function fresh_in_aexpr (id : id) (a: aexpr) : bool
    variant { a }
  = match a with
    | Acst _ -> true
    | Avar v   -> id <> v
    | Asub a1 a2 -> fresh_in_aexpr id a1 && fresh_in_aexpr id a2
    end

  let rec function fresh_in_bexpr (id: id) (b: bexpr) : bool
    variant { b }
  = match b with
    | Bleq a1 a2 -> fresh_in_aexpr id a1 && fresh_in_aexpr id a2
    | _ -> true
    end

  let rec function fresh_in_formula (id: id) (f: formula) : bool
    variant { f }
  = match f with
    | Fterm b -> fresh_in_bexpr id b
    | Fand f1 f2 | Fimp f1 f2 -> fresh_in_formula id f1 && fresh_in_formula id f2
    | Fnot f -> fresh_in_formula id f
    | Fall y f -> id <> y && fresh_in_formula id f
    end

  let rec fresh_from_aux (f: formula) (id : id) : id
      diverges
  =
      if fresh_in_formula id f then id
      else fresh_from_aux f (id + 1)

  let fresh_from (f: formula) : id
      diverges
  =   fresh_from_aux f 0


  (* predicate valid_formula (f: formula) = forall st. eval_formula st f *)




end
