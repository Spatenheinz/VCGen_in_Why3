module Evaluator
  use grammar.Grammar
  use semantics.Semantics
  use int.Int
  (* use fmap.MapImp as M *)
  (* clone fmap.MapImp as M with type key = id, val eq = Int.(=) *)
  (* use map.Const *)
  use option.Option
  (* use ocaml.Exceptions *)
  use dict.Imperative as E
  use map.Map
  (* exception Unbound *)

  type state' = E.t id int
  (* type state2 = M.t (option int) *)
  let sigma : state' = E.empty ()
  (* let sigma2 : state2 = M.create () *)

  let rec aeval (a: aexpr) : int
    variant { a }
    ensures { eval_aexpr a sigma (Eint result) }
    raises { E.Var_unbound -> eval_aexpr a sigma Eunbound }
  = match a with
    | Acst i -> i
    | Avar v ->  E.find sigma v
    | Asub a1 a2 -> aeval a1 - aeval a2
  end

  (* can we not use finite maps???? *)
  (* val myfind (d: state2) (k: id) : int *)
  (*   ensures { match M.find k d with None -> false | Some v -> result = v end } *)
  (*   raises  { Not_found -> M.find k d = None} *)

  (* let rec aeval2 (a: aexpr) : int *)
  (*   variant { a } *)
  (*   ensures { eval_aexpr a sigma2 (Eint result) } *)
  (*   raises { Not_found -> eval_aexpr a sigma2 Eunbound } *)
  (* = match a with *)
  (*   | Acst i -> i *)
  (*   | Avar v ->  myfind sigma2 v *)
  (*   | Asub a1 a2 -> aeval2 a1 - aeval2 a2 *)
  (* end *)

  let rec beval (b: bexpr) : bool
    variant { b }
    ensures { eval_bexpr b sigma (Ebool result) }
    raises { E.Var_unbound -> eval_bexpr b sigma Eunbound }
  = match b with
    | Btrue      -> true
    | Bfalse     -> false
    | Bleq a1 a2 -> aeval a1 <= aeval a2
    (* Cannot be proven *)
    | Band b1 b2 -> beval b1 && beval b2
    | Bnot b     -> not (beval b)
  end

  let rec seval (s: stmt) : ()
     diverges
     ensures {
       eval_stmt (old sigma) s sigma Snormal
     }
     raises {
       E.Var_unbound -> eval_stmt (old sigma) s sigma Sunbound
     }
  = match s with
    | Sskip -> ()
    | Sass x a -> E.set sigma x (aeval a)
    | Sseq s1 s2 -> seval s1; seval s2
    end


end
