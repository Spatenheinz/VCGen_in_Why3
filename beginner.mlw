module List
  type list 'a = Nil | Cons 'a (list 'a)

  predicate mem (x: 'a) (l: list 'a) = match l with
    | Nil -> false
    | Cons y r -> x = y \/ mem x r
  end

  goal G1: mem 2 (Cons 1 (Cons 2 (Cons 3 Nil)))

end

module Length
  use List
  use int.Int

  (* let function length (l: list 'a) : int = match l with *)
  (*   | Nil -> 0 *)
  (*   | Cons _ r -> length r + 1 *)
  (* end *)
  function length (l: list 'a) : int
    (* variant { l } *)
  = match l with
    | Nil -> 0
    | Cons _ r -> length r + 1
  end

  let rec lemma length_nonnegative2(l: list 'a)
      ensures{ length(l) >= 0 }
      variant{ l }
  = match l with
      | Nil -> ()
      | Cons _ r -> length_nonnegative2(r)
  end

  lemma length_nonnegative1: forall l: list 'a. length(l) >= 0

end
